/*Copyright (c) 2001-2003 M. Scott MarcyAll Rights ReservedThis program is free software; you can redistribute it and/ormodify it under the terms of the GNU General Public Licenseas published by the Free Software Foundation; either version 2of the License, or (at your option) any later version.This program is distributed in the hope that it will be useful,but WITHOUT ANY WARRANTY; without even the implied warranty ofMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See theGNU General Public License for more details.You should have received a copy of the GNU General Public Licensealong with this program; if not, write to the Free SoftwareFoundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.This file contains globals needed by the Altivec-coded portions of Starfish.It also contains vector-based functions which replace those found in vMathLib.The replacement functions are here because the corresponding functions invMathLib are either not accurate enough for our use (vCosf, vSinf), oroutright wrong (vFModf).vCosf and vSinf functions are based on algorithms from:MgcFastFunction.cpp// Magic Software, Inc.// http://www.magic-software.com// Copyright (c) 2000, 2001.  All Rights Reserved// FREE SOURCE CODE// http://www.magic-software.com/License/free.pdf//// The approximation formulas are from////   Handbook of Mathematical Functions//   Edited by M. Abramowitz and I.A. Stegun.//   Dover Publications, Inc.//   New York, NY//   Ninth printing, December 1972*/#if BUILD_ALTIVEC#ifndef USE_REPLACEMENT_TRIG_FUNCS#define USE_REPLACEMENT_TRIG_FUNCS	0		// Set to 1 to use the vCosf, vSinf & vATan2f in this file instead of the buggy one in OS 9#endif#include "starfish-altivec.h"#if BUILD_10#include "greymap.h"#endif// Globals ///////////////const vector signed int		gZero			= (vector signed int)	(0, 0, 0, 0);const vector signed int		gZeroOneTwoThree= (vector signed int)	(0, 1, 2, 3);const vector signed int		gOne			= (vector signed int)	(1, 1, 1, 1);const vector unsigned int	gTwo			= (vector unsigned int)(2, 2, 2, 2);			// Used to rotate right 2 (divide by 4)const vector unsigned int	gEight			= (vector unsigned int)(8, 8, 8, 8);			// Used to rotate right 8 (divide by 256)const vector float			gZeroF			= (vector float)		(0.0, 0.0, 0.0, 0.0);const vector float			gOneFourth		= (vector float)		(0.25, 0.25, 0.25, 0.25);const vector float			gOneHalf		= (vector float)		(0.5, 0.5, 0.5, 0.5);const vector float			gOneThird		= (vector float)		(0.33333333333, 0.33333333333, 0.33333333333, 0.33333333333);const vector float			gOneF			= (vector float)		(1.0, 1.0, 1.0, 1.0);const vector float			gTwoF			= (vector float)		(2.0, 2.0, 2.0, 2.0);const vector float			gThreeF			= (vector float)		(3.0, 3.0, 3.0, 3.0);const vector float			gHalfPi			= (vector float)		(1.57079632679, 1.57079632679, 1.57079632679, 1.57079632679);const vector float			gHalfPiRecip	= (vector float)		(0.63661977237, 0.63661977237, 0.63661977237, 0.63661977237);const vector float			gPi				= (vector float)		(3.14159265359, 3.14159265359, 3.14159265359, 3.14159265359);const vector float			gTwoPi			= (vector float)		(6.28318530718, 6.28318530718, 6.28318530718, 6.28318530718);const vector float			gMinusOneF		= (vector float)		(-1.0, -1.0, -1.0, -1.0);const vector float			gMinusTwoF		= (vector float)		(-2.0, -2.0, -2.0, -2.0);const vector float			gMinusPi		= (vector float)		(-3.14159265359, -3.14159265359, -3.14159265359, -3.14159265359);const vector float			gNaN			= (vector float)		(0x7FC00000, 0x7FC00000, 0x7FC00000, 0x7FC00000);#if BUILD_10const vector signed int		gMinChanVal		= (vector signed int)	(0.0, 0.0, 0.0, 0.0);const vector signed int		gMaxChanVal		= (vector signed int)	(MAX_CHANVAL, MAX_CHANVAL, MAX_CHANVAL, MAX_CHANVAL);const vector float			gMaxChanValF	= (vector float)		(MAX_CHANVAL, MAX_CHANVAL, MAX_CHANVAL, MAX_CHANVAL);const vector signed int		gChannelRange 	= (vector signed int)	(CHANNEL_RANGE, CHANNEL_RANGE, CHANNEL_RANGE, CHANNEL_RANGE);// We multiply by this to normalize our byte image values to floats in [0.0-1.0]const vector float			gNormalizer		= (vector float)		(1.0/CHANNEL_RANGE, 1.0/CHANNEL_RANGE, 1.0/CHANNEL_RANGE, 1.0/CHANNEL_RANGE);#endif// These vectors are the control vectors for vec_perm operations.// Color channels are always the 'b' parameter, alpha or the output vector are in the 'a' parameter// (0x10 values indicate 'don't care' (we'll establish the real values at these positions with subsequent vec_perm calls)#ifdef MAC_OSX_PIXEL_ORDER// Mac OS X expects pixels in R-G-B-A orderconst vector unsigned char	gExtractAlphaAndRed = (vector unsigned char) (0x13, 0x10, 0x10, 0x03,	// r0, xx, xx, a0																		  0x17, 0x10, 0x10, 0x07,	// r1, xx, xx, a1																		  0x1B, 0x10, 0x10, 0x0B,	// r2, xx, xx, a2																		  0x1F, 0x10, 0x10, 0x0F);	// r3, xx, xx, a3const vector unsigned char	gExtractGreen       = (vector unsigned char) (0x00, 0x13, 0x10, 0x03,	// r0, g0, xx, a0																		  0x04, 0x17, 0x10, 0x07,	// r1, g1, xx, a1																		  0x08, 0x1B, 0x10, 0x0B,	// r2, g2, xx, a2																		  0x0C, 0x1F, 0x10, 0x0F);	// r3, g3, xx, a3const vector unsigned char	gExtractBlue        = (vector unsigned char) (0x00, 0x01, 0x13, 0x03,	// r0, g0, b0, a0																		  0x04, 0x05, 0x17, 0x07,	// r1, g1, b1, a1																		  0x08, 0x09, 0x1B, 0x0B,	// r2, g2, b2, a2																		  0x0C, 0x0D, 0x1F, 0x0F);	// r3, g3, b3, a3#else// Mac OS 9 expects pixels in A-R-G-B orderconst vector unsigned char	gExtractAlphaAndRed = (vector unsigned char) (0x03, 0x13, 0x10, 0x10,	// a0, r0, xx, xx																		  0x07, 0x17, 0x10, 0x10,	// a1, r1, xx, xx																		  0x0B, 0x1B, 0x10, 0x10,	// a2, r2, xx, xx																		  0x0F, 0x1F, 0x10, 0x10);	// a3, r3, xx, xxconst vector unsigned char	gExtractGreen       = (vector unsigned char) (0x00, 0x01, 0x13, 0x10,	// a0, r0, g0, xx																		  0x04, 0x05, 0x17, 0x10,	// a1, r1, g1, xx																		  0x08, 0x09, 0x1B, 0x10,	// a2, r2, g2, xx																		  0x0C, 0x0D, 0x1F, 0x10);	// a3, r3, g3, xxconst vector unsigned char	gExtractBlue        = (vector unsigned char) (0x00, 0x01, 0x02, 0x13,	// a0, r0, g0, b0																		  0x04, 0x05, 0x06, 0x17,	// a1, r1, g1, b1																		  0x08, 0x09, 0x0A, 0x1B,	// a2, r2, g2, b2																		  0x0C, 0x0D, 0x0E, 0x1F);	// a3, r3, g3, b3#endif#if TEST_ALTIVEC_GENERATORSunsigned int				gNumPixelsGenerated;unsigned int				gNumAltivecPixelsOOB;#endifvector signed int vSplati(int value){	vector_accessor		temp;	temp.sl[0] = temp.sl[1] = temp.sl[2] = temp.sl[3] = value;	// Stuff into our union	return temp.vsl;} // vSplativector float vSplatf(float value){	vector_accessor		temp;	temp.f[0] = temp.f[1] = temp.f[2] = temp.f[3] = value;	// Stuff into our union	return temp.vf;} // vSplatfvector unsigned int vSplatSelector(Boolean sel){	vector_accessor		temp;	temp.l[0] = temp.l[1] = temp.l[2] = temp.l[3] = (sel ? 0xFFFFFFFFL : 0x00000000L);	// Stuff into our union	return temp.vl;} // vSplatSelector#if USE_REPLACEMENT_TRIG_FUNCS// vSinf and vCosf in vMathLib are not accurate enough for some of the generators so we have to roll our own.const vector float			gCosMagic0		= (vector float)		(-2.605e-07, -2.605e-07, -2.605e-07, -2.605e-07);const vector float			gCosMagic1		= (vector float)		(2.47609e-05, 2.47609e-05, 2.47609e-05, 2.47609e-05);const vector float			gCosMagic2		= (vector float)		(-1.3888397e-03, -1.3888397e-03, -1.3888397e-03, -1.3888397e-03);const vector float			gCosMagic3		= (vector float)		(4.16666418e-02, 4.16666418e-02, 4.16666418e-02, 4.16666418e-02);const vector float			gCosMagic4		= (vector float)		(-4.999999963e-01, -4.999999963e-01, -4.999999963e-01, -4.999999963e-01);vector float vCosf(VECTOR float fT){    // assert:  0 <= fT <= PI/2    // maximum absolute error = 2.3082e-09	VECTOR float	pi, twoPi, minusPi, halfPi, one, zero;	VECTOR float	fResult, fTSqr, sign;	pi       = gPi;	twoPi    = gTwoPi;	minusPi  = gMinusPi;	halfPi   = gHalfPi;	one      = gOneF;	zero     = gZeroF;	fT = vFModf(fT, twoPi);	fT = vec_sel(fT, vec_sub(fT, twoPi), vec_cmpgt(fT, pi));	fT = vec_sel(fT, vec_add(fT, twoPi), vec_cmpgt(minusPi, fT));	// Now flip any negative inputs positive (reduces range to [0, pi])	fT = vec_abs(fT);	// Determine the sign of the final output (|fT| > pi/2 is negative)	sign = vec_sel(one, gMinusOneF, vec_cmpgt(fT, halfPi));	// Finally, bring any value > pi/2 into the [0, pi/2] range	fT = vec_sel(fT, vec_sub(pi, fT), vec_cmpgt(fT, halfPi));//     MgcReal fTSqr = fT*fT;//     MgcReal fResult = -2.605e-07;//     fResult *= fTSqr;//     fResult += 2.47609e-05;//     fResult *= fTSqr;//     fResult -= 1.3888397e-03;//     fResult *= fTSqr;//     fResult += 4.16666418e-02;//     fResult *= fTSqr;//     fResult -= 4.999999963e-01;//     fResult *= fTSqr;//     fResult += 1.0;//     return fResult;//  MgcReal fTSqr = fT*fT;	fTSqr   = vec_madd(fT, fT, zero);//  MgcReal fResult = -2.605e-07;	fResult = gCosMagic0;//  fResult *= fTSqr;//  fResult += 2.47609e-05;	fResult = vec_madd(fResult, fTSqr, gCosMagic1);//  fResult *= fTSqr;//  fResult -= 1.3888397e-03;	fResult = vec_madd(fResult, fTSqr, gCosMagic2);//  fResult *= fTSqr;//  fResult += 4.16666418e-02;	fResult = vec_madd(fResult, fTSqr, gCosMagic3);//  fResult *= fTSqr;//  fResult -= 4.999999963e-01;	fResult = vec_madd(fResult, fTSqr, gCosMagic4);//  fResult *= fTSqr;//  fResult += 1.0;	fResult = vec_madd(fResult, fTSqr, one);	return vec_madd(fResult, sign, zero);} // vCosfconst vector float			gSinMagic0		= (vector float)		(-2.39e-08, -2.39e-08, -2.39e-08, -2.39e-08);const vector float			gSinMagic1		= (vector float)		(2.7526e-06, 2.7526e-06, 2.7526e-06, 2.7526e-06);const vector float			gSinMagic2		= (vector float)		(-1.98409e-04, -1.98409e-04, -1.98409e-04, -1.98409e-04);const vector float			gSinMagic3		= (vector float)		(8.3333315e-03, 8.3333315e-03, 8.3333315e-03, 8.3333315e-03);const vector float			gSinMagic4		= (vector float)		(-1.666666664e-01, -1.666666664e-01, -1.666666664e-01, -1.666666664e-01);vector float vSinf(VECTOR float fT){    // assert:  0 <= fT <= PI/2    // maximum absolute error = 2.3279e-09	VECTOR float	pi, twoPi, minusPi, one, zero;	VECTOR float	fResult, fTSqr, sign;	pi       = gPi;	twoPi    = gTwoPi;	minusPi  = gMinusPi;	one      = gOneF;	zero     = gZeroF;	// Bring the input into [-pi, pi]	fT = vFModf(fT, twoPi);	fT = vec_sel(fT, vec_sub(fT, twoPi), vec_cmpgt(fT, pi));	fT = vec_sel(fT, vec_add(fT, twoPi), vec_cmpgt(minusPi, fT));	// Determine the sign of the final output (ft < 0 is negative)	sign = vec_sel(one, gMinusOneF, vec_cmpgt(zero, fT));	// Now flip any negative inputs positive (reduces range to [0, pi])	fT = vec_abs(fT);	// Finally, bring any value > pi/2 into the [0, pi/2] range	fT = vec_sel(fT, vec_sub(pi, fT), vec_cmpgt(fT, gHalfPi));//     MgcReal fTSqr = fT*fT;//     MgcReal fResult = -2.39e-08;//     fResult *= fTSqr;//     fResult += 2.7526e-06;//     fResult *= fTSqr;//     fResult -= 1.98409e-04;//     fResult *= fTSqr;//     fResult += 8.3333315e-03;//     fResult *= fTSqr;//     fResult -= 1.666666664e-01;//     fResult *= fTSqr;//     fResult += 1.0;//     fResult *= fT;//     return fResult;//  MgcReal fTSqr = fT*fT;	fTSqr   = vec_madd(fT, fT, zero);//  MgcReal fResult = -2.39e-08;	fResult = gSinMagic0;//  fResult *= fTSqr;//  fResult += 2.7526e-06;	fResult = vec_madd(fResult, fTSqr, gSinMagic1);//  fResult *= fTSqr;//  fResult -= 1.98409e-04;	fResult = vec_madd(fResult, fTSqr, gSinMagic2);//  fResult *= fTSqr;//  fResult += 8.3333315e-03;	fResult = vec_madd(fResult, fTSqr, gSinMagic3);//  fResult *= fTSqr;//  fResult -= 1.666666664e-01;	fResult = vec_madd(fResult, fTSqr, gSinMagic4);//  fResult *= fTSqr;//  fResult += 1.0;	fResult = vec_madd(fResult, fTSqr, one);//  fResult *= fT;	fResult = vec_madd(fResult, fT, zero);	return vec_madd(fResult, sign, zero);} // vSinf#define validateATan2	0	// Set to one to have us compare our results with scalar atan2()const vector float			gATanMagic0		= (vector float)		( 0.0208351,  0.0208351,  0.0208351,  0.0208351);const vector float			gATanMagic1		= (vector float)		(-0.085133,  -0.085133,  -0.085133,  -0.085133 );const vector float			gATanMagic2		= (vector float)		( 0.180141,   0.180141,   0.180141,   0.180141 );const vector float			gATanMagic3		= (vector float)		(-0.3302995, -0.3302995, -0.3302995, -0.3302995);const vector float			gATanMagic4		= (vector float)		( 0.999866,   0.999866,   0.999866,   0.999866 );#if validateATan2const vector float			gMaxATan2Diff	= (vector float)		( 0.000100,   0.000100,   0.000100,   0.000100 );#endifvector float vATan2f(vector float xv, vector float yv){#if validateATan2	vector_accessor		x, y, r;	x.vf = xv;	y.vf = yv;	r.f[0] = atan2(y.f[0], x.f[0]);	r.f[1] = atan2(y.f[1], x.f[1]);	r.f[2] = atan2(y.f[2], x.f[2]);	r.f[3] = atan2(y.f[3], x.f[3]);#endif// Definition of atan2(y, x) WRT atan, from man atan2(3):////	atan2(y, x) :=  atan(y/x)                       if x > 0,//					sign(y)*(pi - atan(|y/x|))      if x < 0,//					0                               if x = y = 0, or//					sign(y)*pi/2                    if x = 0 y.    // assert:  |fT| <= 1		(for atan2, fT = y/x)    // maximum absolute error = 1.1492e-05	vector bool int		xNeg, yNeg, swapXY;	vector float		fT, fResult, fTSqr;	// Get sign of X & Y values	xNeg = vec_cmplt(xv, gZeroF);	yNeg = vec_cmplt(yv, gZeroF);	xv = vec_sel(xv, vec_sub(gZeroF, xv), xNeg);	// |xv|	yv = vec_sel(yv, vec_sub(gZeroF, yv), yNeg);	// |yv|	// Calculate fT (y/x if y <= x, or x/y if y > x)	// Do we need to swap X & Y?	swapXY = vec_cmpgt(yv, xv);	fT = vec_sel(vDivf(yv, xv), vDivf(xv, yv), swapXY);	// But if x == 0, fT is 0	fT = vec_sel(fT, gZeroF, vec_cmpeq(xv, gZeroF));// 	MgcReal fTSqr = fT*fT;	fTSqr = vec_madd(fT, fT, gZeroF);// 	MgcReal fResult = 0.0208351;// 	fResult *= fTSqr;// 	fResult -= 0.085133;	fResult = vec_madd(gATanMagic0, fTSqr, gATanMagic1);// 	fResult *= fTSqr;// 	fResult += 0.180141;	fResult = vec_madd(fResult, fTSqr, gATanMagic2);// 	fResult *= fTSqr;// 	fResult -= 0.3302995;	fResult = vec_madd(fResult, fTSqr, gATanMagic3);// 	fResult *= fTSqr;// 	fResult += 0.999866;	fResult = vec_madd(fResult, fTSqr, gATanMagic4);// 	fResult *= fT;	fResult = vec_madd(fResult, fT, gZeroF);	// Now we've got to correct it for the octant we're in	// if we swapped X & Y, the result is either (1/4Pi, 3/4Pi) or (-3/4Pi, -1/4Pi)	// so subtract fResult from 1/2Pi (doesn't account for x < 0 case, that's below)	fResult = vec_sel(fResult, vec_sub(gHalfPi, fResult), swapXY);	// if X is negative, subtract the result from Pi	fResult = vec_sel(fResult, vec_sub(gPi, fResult), xNeg);	// if Y is negative, we want the negative of what we have now	fResult = vec_sel(fResult, vec_sub(gZeroF, fResult), yNeg);#if validateATan2	x.vf = vec_sub(fResult, r.vf);	if (!vec_all_in(x.vf, gMaxATan2Diff))		printf("break here--vATan2f() not accurate enough.\n");#endif	return fResult;} // vATan2fvector float vSqrtfX(VECTOR float x){	VECTOR float	temp = x;	temp = vSqrtf(temp);	// Force any NaNs to zero (vMathLib's vSqrtf() returns NaN for input values of 0.0).	if (vec_any_nan(temp) || vec_any_eq(x, gZeroF)) {		// We have to do it the hard way, since NaNs are always unordered and can't be compared specifically		vector_accessor		temp2;		temp2.vf = temp;		if (vec_any_nan(vec_splat(temp, 0)))			temp2.f[0] = 0;		if (vec_any_nan(vec_splat(temp, 1)))			temp2.f[1] = 0;		if (vec_any_nan(vec_splat(temp, 2)))			temp2.f[2] = 0;		if (vec_any_nan(vec_splat(temp, 3)))			temp2.f[3] = 0;		temp = temp2.vf;	} // if	return temp;} // vSqrtfX#endif // USE_REPLACEMENT_TRIG_FUNCS// NOTE: all Starfish calls to vFModf always pass a constant and positive value for y// Because of this, we don't have to do the extra sign stuff, since the output will// always have the same sign as x (which is supposed to be the case, according to the// definition of fmod() in K&R's "The C Programming Language, 2nd Ed." pg 251).// If you ever need to pass potentially negative values for y, uncommend the commented lines.//// vFModf() is only used by the starfish 1.x enginevector float vFModf(VECTOR float X, VECTOR float Y){	VECTOR float	x = X, y = Y;	VECTOR float	zero, intPart, remainder;;//	VECTOR float	sign;	zero = gZeroF;	// The sign of the output is the same as the sign of x//	sign = vec_sel(gOneF, gMinusOneF, vec_cmpgt(zero, x));//	x = vec_abs(x);//	y = vec_abs(y);	intPart = vec_trunc(vDivf(x, y));			// Number of times y "goes into" x	remainder = vec_sub(x, vec_madd(intPart, y, zero));	// Finally, apply the correct sign//	return vec_madd(remainder, sign, zero);	return remainder;} // vFModf#endif	// BUILD_ALTIVEC