/*Copyright (c) 2001 M. Scott MarcyAll Rights ReservedThis program is free software; you can redistribute it and/ormodify it under the terms of the GNU General Public Licenseas published by the Free Software Foundation; either version 2of the License, or (at your option) any later version.This program is distributed in the hope that it will be useful,but WITHOUT ANY WARRANTY; without even the implied warranty ofMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See theGNU General Public License for more details.You should have received a copy of the GNU General Public Licensealong with this program; if not, write to the Free SoftwareFoundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.This file contains the code to create Starfish patterns from Macintosh MP tasks.*/#if BUILD_MP#include <Events.h>#include <Multiprocessing.h>#include "starfish-engine.h"#include "mp_macgen.h"#include "starfish-altivec.h"#define kMPTaskStackSize	(16 * 1024)#define kMPTaskOptions		0typedef struct {	MPSemaphoreID	dataReady;	MPSemaphoreID	abort;	MPTaskID		taskID;	MacGenRef		macRef;	PixMapHandle	destpix;	int				firstLine;	int				lastLine;	int				curLine;} MacGen_Task;static UInt16		gNumTasks;static MacGen_Task	*gTasks;static MPQueueID	gNotifyQueue = 0;// Function Prototypes ///////////////////////////static void		CheckForCompletedTasks(void);static void		CleanUpTasks(void);static OSStatus MP_GenerateTextureGWorldPart(void* input);static OSStatus MP_GenerateTextureGWorldPart_AV(void* input);Boolean CanUseMP(void){	// Must have the MP library and more than one processor	return (MPLibraryIsLoaded() && MPProcessorsScheduled() > 1);} // CanUseMPBoolean InitMP(void){	int		i;	if (!MPLibraryIsLoaded())		return false;	gNumTasks = MPProcessorsScheduled();	if (gNumTasks <= 1)		return false;	gTasks = (MacGen_Task*) NewPtrClear(gNumTasks * sizeof(MacGen_Task));	if (gTasks == nil)		return false;	if (MPCreateQueue(&gNotifyQueue) != noErr)		goto fail;	// Create each task	for (i = 0; i < gNumTasks; i++) {		MacGen_Task	*task = &gTasks[i];		if (MPCreateSemaphore(1, 0, &task->dataReady) != noErr || MPCreateSemaphore(1, 0, &task->abort) != noErr)			goto fail;#if BUILD_ALTIVEC		if (MPCreateTask(gUseAltivec ? MP_GenerateTextureGWorldPart_AV : MP_GenerateTextureGWorldPart, task, kMPTaskStackSize,						 gNotifyQueue, (void*) i, 0, kMPTaskOptions, &task->taskID) != noErr)#else		if (MPCreateTask(MP_GenerateTextureGWorldPart, task, kMPTaskStackSize,						 gNotifyQueue, (void*) i, 0, kMPTaskOptions, &task->taskID) != noErr)#endif			goto fail;	} // for	return true;fail:	CleanUpTasks();	return false;} // InitMPint MP_GeneratorDone(void){	int		i;	// We're done if all tasks have stoped	for (i = 0; i < gNumTasks; i++) {		if (gTasks[i].taskID != 0)			return false;		// At least one task is still alive	} // for	return true;	} // MP_GeneratorDoneint MP_GeneratorProgress(void){	int		i, lines;	CheckForCompletedTasks();		// Clean up anybody who's done	// Add up the total number of lines completed by each task	for (i = lines = 0; i < gNumTasks; i++) {		MacGen_Task	*task = &gTasks[i];		lines += (task->curLine - task->firstLine);//		if (lines > 0)//			DebugStr("\pSomething has been generated!");	} // for	return lines;} // MP_GeneratorProgressOSStatus StartMPTasks(MacGenRef macRef){	PixMapHandle	destpix;	UInt32			vMin, vMax, linesPerTask;	OSStatus		status;	int				i;	// Lock down the PixMap	destpix = GetGWorldPixMap(macRef->dest);	LockPixels(destpix);	// Divvy up the pixmap among the available tasks	// Get min and max vertical positions	vMin = 0;	vMax = macRef->dest->portRect.bottom - macRef->dest->portRect.top;	// This is the total number of lines	linesPerTask = vMax / gNumTasks;	for (i = 0; i < gNumTasks; i++) {		MacGen_Task	*task = &gTasks[i];		task->macRef    = macRef;		task->destpix   = destpix;		task->firstLine = task->curLine = vMin;		task->lastLine  = vMin + linesPerTask - 1;		if (i == 0)			task->lastLine += vMax % gNumTasks;	// Give any leftover lines to the first task		vMin = task->lastLine + 1;		// Start this task!		status = MPSignalSemaphore(task->dataReady);		if (status != noErr)			DebugStr("\pError signaling task");	} // for	// vMin should now be equal to vMax	if (vMin != vMax)		DebugStr("\pLogic error in StartMPTasks");	return status;} // StartMPTasksOSStatus StopMPTasks(MacGenRef macRef){	CleanUpTasks();	UnlockPixels(GetGWorldPixMap(macRef->dest));	return noErr;} // StopMPTasks///////////////////////// Internal Routines /////////////////////////#pragma mark -static void CheckForCompletedTasks(void){	void	*param1;	// See if we've got any tasks that have completed	while (MPWaitOnQueue(gNotifyQueue, &param1, NULL, NULL, kDurationImmediate) == noErr) {		int	index = (int) param1;	// First parameter is index of task that's done		// Make sure task index is valid		if (index >= 0 && index < gNumTasks && gTasks[index].taskID != 0) {			// Dump the semaphores we used			MPDeleteSemaphore(gTasks[index].dataReady);			MPDeleteSemaphore(gTasks[index].abort);			gTasks[index].taskID = 0;	// Record that this task is gone		} else			DebugStr("\pGot invalid task index from notification queue!");	} // while} // CheckForCompletedTasksstatic void CleanUpTasks(void){	Boolean		somethingLives;	do {		int			i;		EventRecord	event;		CheckForCompletedTasks();	// Cleans up tasks as they die		// Look for any tasks that haven't completed yet and try to terminate them		somethingLives = false;		for (i = 0; i < gNumTasks; i++) {			MacGen_Task	*task = &gTasks[i];			if (task->taskID != 0) {				MPSignalSemaphore(task->abort);				MPTerminateTask(task->taskID, userCanceledErr);				somethingLives = true;			} // if		} // for		// Give time to other apps while we wait (Note: no way to abort this!)		WaitNextEvent(0, &event, 10, nil);	} while (somethingLives);	if (gNotifyQueue != 0)		MPDeleteQueue(gNotifyQueue);	if (gTasks != nil)		DisposePtr((Ptr) gTasks);} // CleanUpTasksstatic OSStatus MP_GenerateTextureGWorldPart(void* input){	// This is it: the routine that does all the MP work	MacGen_Task		*state = (MacGen_Task*) input;	int				h, v;	int				hMin, hMax;	Boolean			stop = false;	UInt16			rowbytes;	UInt32*			thisLinePix;	// Wait for our input to be specified, then have at it	if (MPWaitOnSemaphore(state->dataReady, kDurationForever) != noErr)		return -1;	// Get min and max horizontal positions	hMin = state->macRef->dest->portRect.left;	hMax = state->macRef->dest->portRect.right;	// Get a pointer to where we store our pixels	rowbytes    = ((*state->destpix)->rowBytes & 0x7FFF);	thisLinePix = (UInt32*)((UInt32) (*state->destpix)->baseAddr + (state->firstLine * rowbytes));	for (v = state->firstLine; v <= state->lastLine && !stop; v++) {		state->curLine = v;		for (h = hMin; h < hMax && !stop; h++) {			pixel			srlColor;#ifndef SCOTTS_OPTIMIZTAIONS			unsigned char*	thisPixel;#endif			//Calculate the pixel value at the current location.			GetStarfishPixel(h - hMin, v, state->macRef->generator, &srlColor);			//Now put this point at the appropriate spot in the grafport.#ifdef SCOTTS_OPTIMIZTAIONS			*thisLinePix++ = *((UInt32*) &srlColor);		// Copy one 32-bit value#else			thisPixel = (unsigned char*) thisLinePix++;			thisPixel[0] = srlColor.alpha;			thisPixel[1] = srlColor.red;			thisPixel[2] = srlColor.green;			thisPixel[3] = srlColor.blue;#endif		} // for		// Update our pointer into the pixmap		thisLinePix += (rowbytes / sizeof(UInt32)) - (hMax - hMin);		// See if we're to stop		if (MPWaitOnSemaphore(state->abort, kDurationMicrosecond) == noErr)			stop = true;	} // for	return (stop ? userCanceledErr : noErr);} // MP_GenerateTextureGWorldPart#if BUILD_ALTIVECstatic OSStatus MP_GenerateTextureGWorldPart_AV(void* input){	// This is it: the routine that does all the MP work	MacGen_Task		*state = (MacGen_Task*) input;	int				h, v;	int				hMin, hMax;	Boolean			stop = false;	UInt16			rowbytes;	UInt32*			thisLinePix;	// Wait for our input to be specified, then have at it	if (MPWaitOnSemaphore(state->dataReady, kDurationForever) != noErr)		return -1;	// Get min and max horizontal positions	hMin = state->macRef->dest->portRect.left;	hMax = state->macRef->dest->portRect.right;	// Get a pointer to where we store our pixels	rowbytes    = ((*state->destpix)->rowBytes & 0x7FFF);	for (v = state->firstLine; v <= state->lastLine && !stop; v++) {		int		extra, endloop = hMax;		state->curLine = v;		extra = endloop % PIXELS_PER_CALL;	// Number of extra pixels		endloop -= extra;					// make it an even multiple		h = hMin;		thisLinePix = (UInt32*)((UInt32) (*state->destpix)->baseAddr + (v * rowbytes));		while (h < endloop && !stop)		{			//Calculate the pixel value at the current location.			GetStarfishPixel_AV(h - hMin, v, state->macRef->generator, (vector unsigned char*) thisLinePix);			thisLinePix += PIXELS_PER_CALL;			h += PIXELS_PER_CALL;		} // while		if (extra != 0 && !stop) {			vector unsigned char		temp[PIXELS_PER_CALL / 4];	// 4 pixels per vector			GetStarfishPixel_AV(h - hMin, v, state->macRef->generator, temp);			BlockMoveData(temp, thisLinePix, extra * sizeof(UInt32));			h += extra;		} // if		// See if we're to stop		if (MPWaitOnSemaphore(state->abort, kDurationMicrosecond) == noErr)			stop = true;	} // for	return (stop ? userCanceledErr : noErr);} // MP_GenerateTextureGWorldPart#endif	// BUILD_ALTIVEC#else#include "mp_macgen.h"Boolean CanUseMP(void){	// Must have the MP library and more than one processor	return false;} // CanUseMP#endif	// BUILD_MP