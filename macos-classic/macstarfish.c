/*StarfishA graphic texture generator.This is the MacOS desktop daemon. It uses the starfish engineto create colourful and exotic desktop patterns and apply themto the MacOS desktop at user-selected intervals.The starfish rendering code can be found in the 'portable' directory.starfish-engine.h contains the main control routines.Copyright ©1999-2003 Mars SaxmanAll Rights ReservedThis program is free software; you can redistribute it and/ormodify it under the terms of the GNU General Public Licenseas published by the Free Software Foundation; either version 2of the License, or (at your option) any later version.This program is distributed in the hope that it will be useful,but WITHOUT ANY WARRANTY; without even the implied warranty ofMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See theGNU General Public License for more details.You should have received a copy of the GNU General Public Licensealong with this program; if not, write to the Free SoftwareFoundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.*/#include <Carbon.h>#include <Windows.h>#include <Dialogs.h>#include <Events.h>#include <Menus.h>#include <ctype.h>#include <string.h>#include <stdio.h>#include <Appearance.h>#include <Resources.h>#include <PLStringFuncs.h>#include <ToolUtils.h>#include <Devices.h>#include <Fonts.h>#include <Quickdraw.h>#include <TextEdit.h>#include <Navigation.h>#include <Files.h>#include "macgen.h"#include "preferences.h"#include "setdesktop.h"/*Various constants, generally used for dialog boxes and the like.*///IDs for the various dialog boxes#define kAboutBoxResID 131#define kPreferencesBoxResID 129#define kStatusBoxResID 130#define kPoliteTimeSlice 5		//measured in ticks#define kGreedyTimeSlice 20		//used when program is in foreground#define kPoliteSleepTime 5#define kGreedySleepTime 1//IDs for various things on the menu barenum menuBarIDs	{	kAppleMenuResID = 127,	kFileMenuResID = 1,	kEditMenuResID = 2,	kAppleMenuAbout = 1,	kFileMenuQuit = 7,	kFileMenuNew = 1,	kFileMenuShowStatus = 3,	kFileMenuClose = 4,	kFileMenuSaveAs = 5,	kEditMenuPreferences = 10,	kPaletteMenuResID = 50	};enum programStates	{	stateIdling = 0,	stateQuitting,	stateGenerating	};enum pictureResourceIDs	{	kLogoPICTID = 1044	};//Size codes are located in macgen.h.//Interval codes are located in preferences.h.int gProgramState = stateIdling;	//uses constants from enum programStatesMacGenRef gCurrentPattern = NULL;	//pointer to the pattern being generated, if it existsint gLastPreviewBoxTicks;			// last time we refreshed the preview boxstatic Boolean EventDialog(EventRecord* event);static void SetMenuStates(void);static void MenuDispatch(long menu);static void EventDrag(WindowPtr wp, Point loc);static void EventGoAway(WindowPtr wp, Point loc);static void EventMouseDown(EventRecord* event);static void EventKeyDown(EventRecord* event);static Boolean IsForeground(void);static void SetupMenus(void);static void MacInitROM(void);pascal OSErr HandleAEQuit (const AppleEvent *theAppleEvent, AppleEvent *reply, long handlerRefCon);static void MacInit(void);static void Quit(void);static void SaveDesktopPictureFile(void);static void StartGenerating(void);static void ContinueGenerating(void);static void StopGenerating(void);static void CheckClock(void);static void CalcNextPatternTime(void);#pragma mark class Dialogclass Dialog	{	public:		Dialog() : mDialogRef(NULL) {}		virtual void Open(void) = 0;		virtual void Close(void) = 0;		virtual void Draw(void) = 0;		virtual bool Event(int item) = 0;		virtual void Drag(Point) {}		virtual void SetMenuStates(void) {}		virtual bool IsModal(void) { return false; }		static Dialog* Active(void);		static Dialog* Lookup(WindowRef ref);	protected:		DialogRef mDialogRef;	};#pragma mark class StatusWindowclass StatusWindow : public Dialog	{	public:		void Open(void);		void Close(void);		bool Event(int item);		void SetMenuStates(void);		void Draw(void);		void Drag(Point pt);		void SetControlStates(void);	protected:		void DrawPreviewBox(void);		void GetPalettePopup(void);		void SetPalettePopup(void);		//IDs for items in the DLOG		enum statusItemIDs			{			kNewDesktopBtnID = 1,			kCancelBtnID = 2,			kPreviewBoxID = 3,			kSizePopupID = 4,			kPalettePopupID = 5			};		enum paletteMenuIDs			{			paletteFullSpectrumID = 1,			paletteRandomID = 2,			paletteBlankID = 3			};	};#pragma mark class PrefsDialogclass PrefsDialog : public Dialog	{	public:		void Open(void);		void Close(void);		void Draw(void);		bool Event(int item);		virtual bool IsModal(void) { return true; }	protected:		void SetControlStates(void);		void SetIntervalField(void);		void GetIntervalField(void);		void CommitPreferences(void);		UInt16 newWhenCode;		UInt16 newInterval;		UInt16 newIntervalUnits;		UInt16 newFileType;		//IDs for items in preferences box		enum prefsItemIDs			{			kOKBtnID = 1,			kCancelBtnID = 2,			kAtStartupID = 3,			kEveryDayID = 4,			kAtIntervalID = 5,			kOnRequestID = 6,			kIntervalFieldID = 7,			kIntervalUnitsPopupID = 8,			kFileTypePopupID = 9			};	};#pragma mark class AboutBoxclass AboutBox : public Dialog	{	public:		void Open(void);		void Close(void);		void Draw(void);		bool Event(int item);		virtual bool IsModal(void) { return true; }	protected:		enum aboutItemIDs			{			kGoAwayRectID = 1,			kLogoPictureID = 2,			kAboutTextID = 3			};		enum 			{			kAboutTextResourceID = 1047			};	};StatusWindow gStatusWindow;PrefsDialog gPrefsDialog;AboutBox gAboutBox;Dialog* Dialog::Lookup(WindowRef ref)	{	/*	Look for a Dialog object that owns that ref.	If we find one, return it. Otherwise, return NULL.	*/	if(ref == GetDialogWindow(gStatusWindow.mDialogRef)) return &gStatusWindow;	if(ref == GetDialogWindow(gPrefsDialog.mDialogRef)) return &gPrefsDialog;	if(ref == GetDialogWindow(gAboutBox.mDialogRef)) return &gAboutBox;	return NULL;	}Dialog* Dialog::Active(void)	{		// Iterate through the window list. Compare each one against the window ref	// for the two possible windows. If we get a match, return it.	WindowRef test = FrontWindow();	while (test)		{		Dialog* out = Lookup(test);		if (out) return out;		test = GetNextWindow(test);		}	return NULL;	}#pragma mark -void StatusWindow::SetPalettePopup(void)	{	/*	Use the palette number to figure out which item	in the popup menu should be selected.	This isn't a simple linear thing.	*/	short itemType;	ControlHandle itemHandle;	Rect itemRect;	if(mDialogRef)		{		GetDialogItem(mDialogRef, kPalettePopupID, &itemType, &(Handle)itemHandle, &itemRect);		if(itemHandle)			{			switch(gPrefs.palette)				{				case paletteFullSpectrum:					SetControlValue(itemHandle, paletteFullSpectrumID);					break;				case paletteRandom:					SetControlValue(itemHandle, paletteRandomID);					break;				default:					/*					Get the name of the specified resource.					Then get the popup menu that holds the palette names.					Walk through the items in the menu, comparing each one against					the resource name. When we find a match, set the control's value					to the number of the matching item.					*/					{					unsigned char resname[256];					SInt16 unused1;					ResType unused2;					Handle reshandle;					MenuHandle popmenu;					int hitflag = false;					unsigned char menuname[256];					//The default value is "full spectrum".					SetControlValue(itemHandle, paletteFullSpectrumID);					reshandle = Get1Resource('pltt', gPrefs.palette);					if(reshandle)						{						//Get the name and other info for this resource.						GetResInfo(reshandle, &unused1, &unused2, resname);						//Now we know the name of this resource. Get the menu handle we will inspect.						popmenu = GetMenu(kPaletteMenuResID);						if(popmenu)							{							int ctr;							for(ctr = paletteBlankID; ctr < CountMenuItems(popmenu); ctr++)								{								GetMenuItemText(popmenu, ctr, menuname);								if(!PLstrcmp(menuname, resname))									{									SetControlValue(itemHandle, ctr);									hitflag = true;									}								}							if(!hitflag) gPrefs.palette = paletteFullSpectrum;							}						else gPrefs.palette = paletteFullSpectrum;						ReleaseResource(reshandle);						}					else gPrefs.palette = paletteFullSpectrum;					}					break;				}			}		}	}void StatusWindow::GetPalettePopup(void)	{	short itemType;	ControlHandle itemHandle;	Rect itemRect;	if(mDialogRef)		{		GetDialogItem(mDialogRef, kPalettePopupID, &itemType, &(Handle)itemHandle, &itemRect);		if(itemHandle)			{			SInt16 popupval = GetControlValue((ControlHandle)itemHandle);			switch(popupval)				{				case paletteFullSpectrumID:					gPrefs.palette = paletteFullSpectrum;					break;				case paletteRandomID:					gPrefs.palette = paletteRandom;					break;				case paletteBlankID:					//do nothing - this is a divider and can't actually be selected					break;				default:					/*					This is not one of the magic menu items.					It is one of the list of palettes included in Starfish.					So we get the name of the specified item, use that to load					the associated 'pltt' resource, then get info on *that* to discover					what the palette's resource ID is. The resource ID is what we end					up using.					*/					{						MenuHandle popmenu;						unsigned char menutext[256];						Handle reshandle;						SInt16 resid;						ResType unused;						popmenu = GetMenu(kPaletteMenuResID);						if(popmenu)							{							GetMenuItemText(popmenu, popupval, menutext);							reshandle = Get1NamedResource('pltt', menutext);							if(reshandle)								{								GetResInfo(reshandle, &resid, &unused, menutext);								gPrefs.palette = resid;								ReleaseResource(reshandle);								}							else gPrefs.palette = paletteFullSpectrum;							}						else gPrefs.palette = paletteFullSpectrum;					}				}			}		}	}void StatusWindow::SetControlStates(void)	{	short itemType;	ControlHandle itemHandle;	Rect itemRect;	if(!mDialogRef) return;	bool generating = (gProgramState == stateGenerating);	// We have a bunch of controls that need to be enabled or disabled depending	// on whether we are generating a pattern or not. 	struct {int itemID; bool state;} flags[] = 		{		{kNewDesktopBtnID, false},		{kCancelBtnID, true},		{kSizePopupID, false},		{kPalettePopupID, false},		{0,false}	// terminator		};	for (int ctr = 0; flags[ctr].itemID; ctr++)		{		GetDialogItem(mDialogRef, flags[ctr].itemID, &itemType, (Handle*)&itemHandle, &itemRect);		if(itemHandle)			{			if (generating ^ flags[ctr].state) DeactivateControl(itemHandle);			else ActivateControl(itemHandle);			}		}	// Set the popup values to match the preference settings.	GetDialogItem(mDialogRef, kSizePopupID, &itemType, (Handle*)&itemHandle, &itemRect);	if(itemHandle) SetControlValue(itemHandle, gPrefs.size);	}void StatusWindow::SetMenuStates(void)	{	MenuRef fileMenuHandle;	fileMenuHandle = GetMenuHandle(kFileMenuResID);	if(fileMenuHandle)		{		/*		Enable the "Close" item if the window is currently open.		Disable it if the window is not open.		*/		if(mDialogRef)			{			EnableMenuItem(fileMenuHandle,kFileMenuClose);			}		else			{			DisableMenuItem(fileMenuHandle,kFileMenuClose);			}		}	}void StatusWindow::DrawPreviewBox(void)	{	short itemType;	ControlHandle itemHandle;	Rect itemRect;	if(mDialogRef)		{		SetPort((GrafPtr)GetWindowPort(GetDialogWindow(mDialogRef)));		RGBColor oldBack, newBack;		GetBackColor(&oldBack);		RgnHandle maskRgn = NewRgn();		//The preview box is a user item.		GetDialogItem(mDialogRef, kPreviewBoxID, &itemType, (Handle*)&itemHandle, &itemRect);		//We expect to draw over a white background.		newBack.red = newBack.green = newBack.blue = 0xFFFF;		RGBBackColor(&newBack);		FrameRect(&itemRect);		InsetRect(&itemRect, 1, 1);		bool drawn = false;		if(gCurrentPattern)			{			//Get the GWorld being drawn as the pattern.			GWorldPtr src = PeekMacGeneratorWorld(gCurrentPattern);			if(src)				{				Rect srcRect;				#if CARBON				GetPortBounds(src,&srcRect);				#else				srcRect = src->portRect;				#endif				Rect destRect = srcRect;				//Copy the image into the preferences dialog. Scaling is expected.				//Scale the image so it fits into the preview area, then center it.				if((destRect.right-destRect.left) > (itemRect.right-itemRect.left))					{					float newWidth = itemRect.right - itemRect.left;					float srcWidth = destRect.right - destRect.left;					float ratio = newWidth / srcWidth;					destRect.left = itemRect.left;					destRect.right = itemRect.right;					destRect.bottom -= destRect.top;					destRect.bottom = destRect.top + destRect.bottom * ratio;					}				if((destRect.bottom-destRect.top) > (itemRect.bottom-itemRect.top))					{					float newHeight = itemRect.bottom - itemRect.top;					float srcHeight = destRect.bottom - destRect.top;					float ratio = newHeight / srcHeight;					destRect.top = itemRect.top;					destRect.bottom = itemRect.bottom;					destRect.right -= destRect.left;					destRect.right = destRect.left + destRect.right * ratio;					}    			OffsetRect(&destRect,        			(itemRect.right + itemRect.left)/2 - (destRect.right + destRect.left)/2,        			(itemRect.top + itemRect.bottom)/2 - (destRect.top + destRect.bottom)/2);				#if CARBON				CopyBits(GetPortBitMapForCopyBits(src), GetPortBitMapForCopyBits(GetDialogPort(mDialogRef)), &srcRect, &destRect, ditherCopy, NULL);				#else				CopyBits((BitMap *)(*(*src).portPixMap), (BitMap *)(*(*mDialogRef).portPixMap), &srcRect, &destRect, ditherCopy, NULL);				#endif				drawn = true;				RectRgn(maskRgn, &destRect);				RGBColor slightlyGrey = {0xEEEE,0xEEEE,0xEEEE};				RGBBackColor(&slightlyGrey);				}			}		if(not drawn)			{			//Draw the Starfish logo centered on the user item.			//If it is bigger than the user item, scale it. Otherwise,			//clear the area surrounding it.			PicHandle logopic = GetPicture(kLogoPICTID);			if(logopic)				{				Rect srcRect = (*logopic)->picFrame;				// Center the picture on the item. We assume the preview frame is				// larger than the logo picture.    			OffsetRect(&srcRect,        			(itemRect.right + itemRect.left)/2 - (srcRect.right + srcRect.left)/2,        			(itemRect.top + itemRect.bottom)/2 - (srcRect.top + srcRect.bottom)/2);				DrawPicture(logopic,&srcRect);				RectRgn(maskRgn,&srcRect);				}			}		// Erase everything in the item rect not covered by the mask.		RgnHandle clearRgn = NewRgn();		RectRgn(clearRgn, &itemRect);		DiffRgn(clearRgn, maskRgn, clearRgn);		EraseRgn(clearRgn);		DisposeRgn(clearRgn);		DisposeRgn(maskRgn);		//Restore the original background colour so we don't mess anything up.		RGBBackColor(&oldBack);		}	}void StatusWindow::Draw(void)	{	if(mDialogRef)		{		RGBColor blackColor = {0x0000, 0x0000, 0x0000};		/*		I don't know why I have to do this. It seems that the window settings		are getting screwed up before we draw. I'm trying to reset them, but		it isn't completely working - the font, size, and mode are working, but		the style is coming out crooked. I don't get it. I suspect something		is getting corrupted here, but I can't imagine what it is.		*/		RGBForeColor(&blackColor);		TextFont(systemFont);		TextSize(12);		TextMode(0);		TextFace(0);		DrawDialog(mDialogRef);		DrawPreviewBox();		}	}bool StatusWindow::Event(int item)	{	short itemType;	ControlHandle itemHandle;	Rect itemRect;	if(mDialogRef) GetDialogItem(mDialogRef, item, &itemType, (Handle*)&itemHandle, &itemRect);	switch (item)		{		case kNewDesktopBtnID:			//Begin generating a new pattern.			StartGenerating();			return true;		case kCancelBtnID:			//Stop generating the pattern currently under way.			StopGenerating();			return true;		case kSizePopupID:			//Change the pattern size code.			if(itemHandle) gPrefs.size = GetControlValue(itemHandle);			return true;		case kPalettePopupID:			GetPalettePopup();			return true;		}	return false;	}void StatusWindow::Drag(Point loc)	{	BitMap screenBits;	Rect dragBounds;	GetQDGlobalsScreenBits(&screenBits);	dragBounds = screenBits.bounds;	DragWindow(GetDialogWindow(mDialogRef), loc, &dragBounds);	Point toppoint;	GrafPtr oldport;	GetPort(&oldport);	SetPort((GrafPtr)GetWindowPort(GetDialogWindow(mDialogRef)));	toppoint.h = toppoint.v = 0;	LocalToGlobal(&toppoint);	SetPort(oldport);	gPrefs.hoff = toppoint.h;	gPrefs.voff = toppoint.v;	}void StatusWindow::Open(void)	{	if(mDialogRef)		{		// The window already exists. Bring it to the front.		ShowWindow(GetDialogWindow(mDialogRef));		return;		}	//Our status window is actually a modeless dialog. Tell the system to create	// it from our DLOG resource.	mDialogRef = GetNewDialog(kStatusBoxResID, NULL, (WindowRef)-1);	if(mDialogRef)		{		/*		Fill out the controls in this dialog box to reflect the preference		settings.		*/		if(gPrefs.hoff || gPrefs.voff) MoveWindow((WindowPtr)mDialogRef, gPrefs.hoff, gPrefs.voff, false);		//Some controls show up differently depending on our program state.		SetControlStates();		SetPalettePopup();		//That's it. Draw the mess we've made.		ShowWindow(GetDialogWindow(mDialogRef));		gPrefs.windowOpen = true;		}	}void StatusWindow::Close(void)	{	if(mDialogRef) DisposeDialog(mDialogRef);	mDialogRef = NULL;	gPrefs.windowOpen = false;	}#pragma mark -void PrefsDialog::GetIntervalField(void)	{	/*	Get the text from the interval field.	Parse it, character by character, until we find something we don't recognize.	Then stop.	When we are done, we will save the result value into the "interval" field of	the preferences.	*/	short itemType;	Handle itemHandle;	Rect itemRect;	unsigned char text[256];	if(mDialogRef)		{		GetDialogItem(mDialogRef, kIntervalFieldID, &itemType, &itemHandle, &itemRect);		if(itemHandle) 			{			int charctr = 1;			GetDialogItemText(itemHandle, text);			newInterval = 0;			// damn pascal strings			while(charctr <= text[0] && isdigit(text[charctr]))				{				//Shift the existing gPrefs value up by one decimal digit.				//Then add the numeric value of this character.				newInterval = (newInterval * 10) + (text[charctr++] - '0');				}			}		}	}void PrefsDialog::SetIntervalField(void)	{	/*	Create a string from the "interval" field of the preferences.	Put it into the interval field.	We have to do tricky c-to-pascal-string conversions here, since	the demise of 'setdialogitemtext' in Carbon.	*/	short itemType;	Handle itemHandle;	Rect itemRect;	unsigned char text[256];	if(mDialogRef)		{		GetDialogItem(mDialogRef, kIntervalFieldID, &itemType, &itemHandle, &itemRect);		if(itemHandle) 			{			sprintf((char*)&text[1], "%d", newInterval);			// set the pascal-string length byte			text[0] = strlen((char*)&text[1]);			SetDialogItemText(itemHandle, text);			}		}	}void PrefsDialog::SetControlStates(void)	{	short itemType;	ControlHandle itemHandle;	Rect itemRect;	if(mDialogRef)		{		//The units popup switches between "by minute" and "by hour".		GetDialogItem(mDialogRef, kIntervalUnitsPopupID, &itemType, (Handle*)&itemHandle, &itemRect);		if(itemHandle) SetControlValue(itemHandle, newIntervalUnits);		//"On request" means generate a pattern only when the user asks for one.		GetDialogItem(mDialogRef, kOnRequestID, &itemType, (Handle*)&itemHandle, &itemRect);		SetControlValue(itemHandle, newWhenCode == whenCodeNever);		//"At startup" means do it once when the program starts up and never again.		GetDialogItem(mDialogRef, kAtStartupID, &itemType, (Handle*)&itemHandle, &itemRect);		SetControlValue(itemHandle, newWhenCode == whenCodeAtStartup);		//"At interval" means either hourly or minutely.		GetDialogItem(mDialogRef, kAtIntervalID, &itemType, (Handle*)&itemHandle, &itemRect);		SetControlValue(itemHandle, newWhenCode == whenCodeInterval);		//"Every day" means just that: once a day, no matter how many restarts.		GetDialogItem(mDialogRef, kEveryDayID, &itemType, (Handle*)&itemHandle, &itemRect);		SetControlValue(itemHandle, newWhenCode == whenCodeDaily);		// File type switches between PICT and JPEG.		GetDialogItem(mDialogRef, kFileTypePopupID, &itemType, (Handle*)&itemHandle, &itemRect);		if(itemHandle) SetControlValue(itemHandle, newFileType);		}	}void PrefsDialog::CommitPreferences(void)	{	gPrefs.when = newWhenCode;	gPrefs.interval = newInterval;	gPrefs.units = newIntervalUnits;	gPrefs.fileType = newFileType;	CalcNextPatternTime();	}void PrefsDialog::Draw(void)	{	if(mDialogRef)		{		DrawDialog(mDialogRef);		}	}bool PrefsDialog::Event(int item)	{	short itemType;	ControlHandle itemHandle;	Rect itemRect;	GetDialogItem(mDialogRef, item, &itemType, (Handle*)&itemHandle, &itemRect);	bool out = false;	switch (item)		{		case kOKBtnID:			// Save the changed preferences and close the dialog.			CommitPreferences();		case kCancelBtnID:			// just close the dialog.			Close();			out = true;			break;		case kOnRequestID:			//Switch the when-mode to "only on request".			newWhenCode = whenCodeNever;			out = true;			break;		case kEveryDayID:			//Once a day, regardless of the number of Starfish launches.			newWhenCode = whenCodeDaily;			out = true;			break;		case kAtStartupID:			//Make a new pattern whenever the program starts up.			newWhenCode = whenCodeAtStartup;			out = true;			break;		case kAtIntervalID:			//Make a new pattern whenever the specified time interval expires.			newWhenCode = whenCodeInterval;			out = true;			break;		case kIntervalFieldID:			//Get the numeric value of the interval typed into the field.			GetIntervalField();			out = true;			break;		case kIntervalUnitsPopupID:			//The new interval-units value is whatever was selected in the menu.			newIntervalUnits = GetControlValue(itemHandle);			out = true;			break;		case kFileTypePopupID:			// new file format value is whatever is selected in the menu.			newFileType = GetControlValue(itemHandle);			out = true;			break;		}	if (out) SetControlStates();	return out;	}void PrefsDialog::Open(void)	{	if(mDialogRef)		{		// The window already exists. Bring it to the front.		ShowWindow(GetDialogWindow(mDialogRef));		return;		}		//Our status window is actually a modeless dialog.	mDialogRef = GetNewDialog(kPreferencesBoxResID, NULL, (WindowRef)-1);	if(mDialogRef)		{		short itemType;		ControlHandle itemHandle;		Rect itemRect;		GetDialogItem(mDialogRef, kOKBtnID, &itemType, (Handle*)&itemHandle, &itemRect);		SetWindowDefaultButton(GetDialogWindow(mDialogRef), itemHandle);		GetDialogItem(mDialogRef, kCancelBtnID, &itemType, (Handle*)&itemHandle, &itemRect);		SetWindowCancelButton(GetDialogWindow(mDialogRef), itemHandle);		/*		Fill out the controls in this dialog box to reflect the preference		settings.		*/		newWhenCode = gPrefs.when;		newInterval = gPrefs.interval;		newIntervalUnits = gPrefs.units;		newFileType = gPrefs.fileType;		SetControlStates();		SetIntervalField();		//That's it. Draw the mess we've made.		ShowWindow(GetDialogWindow(mDialogRef));		}	}void PrefsDialog::Close(void)	{	if(mDialogRef) DisposeDialog(mDialogRef);	mDialogRef = NULL;	}#pragma mark -void AboutBox::Draw(void)	{	// Draw the window normally. This redraws the logo PICT.	if(mDialogRef)		{		DrawDialog(mDialogRef);		SetPort((GrafPtr)GetWindowPort(GetDialogWindow(mDialogRef)));		// Also draw the about-text in the appropriate user item.		short itemType;		ControlHandle itemHandle;		Rect itemRect;		GetDialogItem(mDialogRef, kAboutTextID, &itemType, (Handle*)&itemHandle, &itemRect);		// Load up the about text and draw it, left-justified, inside this item.		Handle aboutText = GetResource('TEXT', kAboutTextResourceID);		if(aboutText)			{			HLock(aboutText);			TextFont(1);	// app font = Geneva			TextSize(10);			TETextBox(*aboutText, GetHandleSize(aboutText), &itemRect, 1);			HUnlock(aboutText);			}		}	}bool AboutBox::Event(int item)	{	#pragma unused(item)	// Clicking the about box simply dismisses it.	Close();	return true;	}void AboutBox::Open(void)	{	if(mDialogRef)		{		// The window already exists. Bring it to the front.		ShowWindow(GetDialogWindow(mDialogRef));		return;		}		//Our status window is actually a modeless dialog.	mDialogRef = GetNewDialog(kAboutBoxResID, NULL, (WindowRef)-1);	}void AboutBox::Close(void)	{	if(mDialogRef) DisposeDialog(mDialogRef);	mDialogRef = NULL;	}	#pragma mark -static void SetMenuStates(void)	{	// See if there is an active dialog. Let it set the menu states.	Dialog* active = Dialog::Active();	if (active)		{		active->SetMenuStates();		}	/*	Enable global menu items that aren't dependent on a window.	Enable "Save As" if we have a picture file saved.	Disable it otherwise.	*/	MenuRef fileMenuHandle;	fileMenuHandle = GetMenuHandle(kFileMenuResID);	if(DesktopPictureFileExists())		{		EnableMenuItem(fileMenuHandle,kFileMenuSaveAs);		}	else		{		DisableMenuItem(fileMenuHandle,kFileMenuSaveAs);		}	}static void MenuDispatch(long menu)	{	short menuID;	short cmdID;	// DAstring is not used under carbon	// Str255 DAString;			menuID = HiWord(menu);	cmdID  = LoWord(menu);	switch(menuID)		{		case kAppleMenuResID:			{			switch (cmdID)				{				case kAppleMenuAbout:					gAboutBox.Open();					break;				default:					/*					One of the uglier bits of the MacOS.					You'd think that the system, having sent us the relevant					MenuSelect results, would *know* that an Apple menu item					had been opened and would, correspondingly, launch the appropriate					item. But instead, *we* have to do it. And the way we have to do					it is sickeningly old fashioned. We get the _text_ of the menu item,					then call OpenDeskAcc() on it, as though we were living back in 1984					and this were some pathetic excuse for multitasking. It's a royal kludge					and everybody knows it.					*/					/*					This is very curious.					OpenDeskAcc is not available in Carbon, but no replacement mechanism					is mentioned in the Carbon docs. Is it possible that Carbon apps do					not have to worry about this particular issue?					*/					#if 0					GetMenuItemText(GetMenuHandle(menuID), cmdID, DAString);					OpenDeskAcc(DAString);					#endif					break;				}			break;			}		case kFileMenuResID:			{			switch (cmdID)				{				case kFileMenuQuit:					Quit();					break;				case kFileMenuNew:					//Start creating a new pattern.					StartGenerating();					break;				case kFileMenuClose:					gStatusWindow.Close();					SetMenuStates();					break;				case kFileMenuSaveAs:					// Make a copy of the current starfish picture file.					SaveDesktopPictureFile();					break;				case kFileMenuShowStatus:					gStatusWindow.Open();					SetMenuStates();				default:					break;				}			break;			}		case kEditMenuResID:			switch (cmdID)				{				case kEditMenuPreferences:					gPrefsDialog.Open();					SetMenuStates();					break;				}			break;		}	}static Boolean EventDialog(EventRecord* event)	{	DialogPtr dp;	DialogItemIndex item;		if (event->modifiers & cmdKey)		{		EventKeyDown(event);		// this allows menu commands while dialog is active window		return false;		}	if (DialogSelect(event, &dp, &item))		{		Dialog* which = Dialog::Lookup(GetDialogWindow(dp));		if (which)			{			return which->Event(item);			}		}	return false;	}static void EventDrag(WindowPtr wp, Point loc)	{	Dialog* which = Dialog::Lookup(wp);	if (which) which->Drag(loc);	}static void EventGoAway(WindowPtr wp, Point loc)	{	Dialog* which = Dialog::Lookup(wp);	if (which && TrackGoAway(wp, loc)) which->Close();	}	static void EventMouseDown(EventRecord* event)	{	short		part;	WindowPtr	wp;	long 		menu;		part = FindWindow(event->where, &wp);	switch (part)		{		case inMenuBar:			menu = MenuSelect(event->where);			HiliteMenu(0);			MenuDispatch(menu);			break;					case inDrag:			EventDrag(wp, event->where);			break;				case inGoAway:			EventGoAway(wp, event->where);			SetMenuStates();			break;				case inContent:					SelectWindow(wp);			break;					case inGrow:		// no grow box		case inZoomIn:		// no zoom box		case inZoomOut:		// no zoom box		case inSysWindow:		case inDesk:		default:			break;		}	}static void EventKeyDown(EventRecord* event)	{	char		c;	long		menu;		c = event->message & charCodeMask;	if (event->modifiers & cmdKey)		{		// cmd key		menu = MenuKey(c);		HiliteMenu(0);		if (menu != 0)			MenuDispatch(menu);		}	else		{		// normal keystroke		}	}static void EventUpdate(EventRecord* event)	{	WindowPtr wp;	wp = (WindowPtr)event->message;	Dialog* which = Dialog::Lookup(wp);	if(which)		{		SetPort(GetWindowPort(wp));		which->Draw();		}	}static void EventLoop(void)	{	EventRecord event;		while (gProgramState != stateQuitting)		{		if (WaitNextEvent(everyEvent, &event, IsForeground() ? kGreedySleepTime : kPoliteSleepTime, 0)) 			{			//If this is a dialog event, go handle it, and don't worry about the event loop.			if (IsDialogEvent(&event) && EventDialog(&event)) continue;			switch (event.what)				{				case keyDown:					EventKeyDown(&event);					break;									case mouseDown:					EventMouseDown(&event);					break;									case updateEvt:					// redraw window now					EventUpdate(&event);					break;								case activateEvt:					// activate or deactivate window controls					// we don't actually do this, because I'm lazy					break;								case kHighLevelEvent:					AEProcessAppleEvent(&event);					break;				case mouseUp:				case keyUp:				case autoKey:				case diskEvt:				case app4Evt:				default:					break;				}			}		/*		We take advantage of every event to do processing.		Since we spend most of our time in the background, and processing		is all we really exist for, this works out well.		*/		if(gProgramState == stateGenerating) ContinueGenerating();		if(gProgramState == stateIdling) CheckClock();		}	}static Boolean IsForeground(void)	{	/*	The Process Manager can tell us whether we are in the foreground	or not. We do this by getting our process serial number and the	foreground's process serial number, then comparing the two PSNs to	see if they are equal. If so, we are in the foreground.	*/	ProcessSerialNumber ourPSN, forePSN;	Boolean out = false;	GetCurrentProcess(&ourPSN);	GetFrontProcess(&forePSN);	SameProcess(&ourPSN, &forePSN, &out);	return out;	}static void SetupMenus(void)	{	MenuHandle mh;	mh = GetMenu(kAppleMenuResID);	if(mh)		{		/*		Yay. In carbon we don't have to manually add DAs to the Apple menu.		AppendResMenu( mh, 'DRVR' );		*/		InsertMenu(mh, 0);		}	mh = GetMenu(kFileMenuResID);	if(mh) InsertMenu(mh, 1);	mh = GetMenu(kEditMenuResID);	if(mh) InsertMenu(mh, 2);	DrawMenuBar();	}static void MacInitROM(void)	{	/*	So far as I know, this entire segment is no longer needed under Carbon.	yaaaaaay!	MoreMasters();	InitGraf(&qd.thePort);	InitFonts();	InitWindows();	InitMenus();	TEInit();	InitDialogs(NULL);	FlushEvents(everyEvent, 0);	*/	InitCursor();	}pascal OSErr HandleAEQuit (const AppleEvent *theAppleEvent, AppleEvent *reply, long handlerRefCon)	{	#pragma unused(theAppleEvent)	#pragma unused(reply)	#pragma unused(handlerRefCon)	//Quit. Easy to do...	Quit();	return noErr;	}static void MacInit(void)	{	MacInitROM();	SetupMenus();	AEInstallEventHandler(kCoreEventClass,kAEQuitApplication,NewAEEventHandlerUPP(&HandleAEQuit),false,false);	}static void Quit(void)	{	/*	One place to do all shutdown tasks.	Don't ever set gProgramState to stateQuitting: call Quit() instead.	*/	//If there is a pattern going, shut it down now.	StopGenerating();	//Set the quit flag so the program dies.	gProgramState = stateQuitting;	}static OSErr CopyPictureFile( FSSpec& dest, OSType creator, OSType type )	{	/*	We know where we're supposed to save the file.	Open the existing file. Read all of its data into a buffer.	Close the existing file.	If the buffer-read succeeded, create the new file. 	If the file-creation succeeded, open the new file.	If the open succeeded, write the buffer into it.	If the open succeeded, close the new file.	Delete the buffer.	*/	OSErr err = noErr;	FSSpec src;	short srcRefNum = 0;	short dstRefNum = 0;	char* tempBuf;	long bufSiz = 0;	AliasHandle starPictFile = FindStarfishPict();	if( !starPictFile ) err = 1;		if( noErr == err )		{		Boolean wasChangedWeDontCare;		err = ResolveAlias( NULL, starPictFile, &src, &wasChangedWeDontCare );		}	if( noErr == err )		{		err = FSpOpenDF( &src, fsRdPerm, &srcRefNum );		if( err ) srcRefNum = 0;		}	if( noErr == err )		{		err = GetEOF( srcRefNum, &bufSiz );		}	if( noErr == err )		{		tempBuf = new char[bufSiz];		if(!tempBuf) err = memFullErr;		}	if( noErr == err )		{		err = FSRead( srcRefNum, &bufSiz, tempBuf );		}	if( noErr == err )		{		err = FSpCreate( &dest, creator, type, 0 );		}	if( noErr == err )		{		err = FSpOpenDF( &dest, fsWrPerm, &dstRefNum );		if( err ) dstRefNum = 0;		}	if( noErr == err )		{		err = FSWrite( dstRefNum, &bufSiz, tempBuf );		}		if( starPictFile ) DisposeHandle((Handle)starPictFile);	if( srcRefNum ) FSClose( srcRefNum );	if( dstRefNum ) FSClose( dstRefNum );	if( tempBuf ) delete[] tempBuf;	return err;	}static pascal void NavEventProc( NavEventCallbackMessage callBackSelector, NavCBRecPtr callBackParms, void *callBackUD )	{	#pragma unused(callBackUD)     switch (callBackSelector)    	{        case kNavCBEvent:            switch (((callBackParms->eventData).eventDataParms).event->what)            	{                case updateEvt:                	EventUpdate( ((callBackParms->eventData).eventDataParms).event );                    break;            	}            break;    	}	}static OSErr CopyOverwritePictureFile( FSSpec& dest, OSType creator, OSType type )	{	/*	This is the same as CopyPictureFile, except that dest already exists.	This is where we would implement the "safe-save" technique, if we were	going to do that. But I looked into it and it's an amazing amount of work.	Never mind that! I'll just delete the original file, then save the new	file where it used to live.	*/	FSpDelete( &dest );	return CopyPictureFile( dest, creator, type );	}void SaveDesktopPictureFile(void)	{	/*	Ask the user where they want to put their new copy of the desktop	picture file. We have to use NavServices for Carbon compatibility.	This isn't so bad, I guess, but I never really saw what was wrong	with StandardFile. But I never customized the dialog boxes, either,	and it looks like a lot of people did that in completely X-unfriendly	ways. NavServices isn't bad, it's just more complicated.	This code is borrowed from the example in Apple's nav services docs,	because it did basically the same thing I wanted to do.	*/	OSErr               anErr = noErr;	NavReplyRecord      reply;	NavDialogOptions    dialogOptions;	OSType              fileTypeToSave = 'PICT';	OSType              creatorType = 'ogle';	NavEventUPP         eventProc = NewNavEventUPP(NavEventProc);	// How on earth could this call ever fail?    anErr = NavGetDefaultDialogOptions(&dialogOptions);    if (anErr == noErr)		{        //  Customize the dialog options.        // We don't want the allow stationery option, because that's stupid        // for a starfish picture.		dialogOptions.dialogOptionFlags = dialogOptions.dialogOptionFlags & (~kNavAllowStationery);		// The name of the client is Starfish, of course.		strncpy( (char*)dialogOptions.clientName, (char*)"\pStarfish", 255 );		/*		Pick a meaningless file name. Since this is a graphical toy instead of		a functional app, it picks a random starfish species name. There is no		point to this, but it's cute. "Starfish" is a completely random name		anyway, and has no particular relationship to the program's function.		I don't remember why I originally picked it. But while I've got it, why		not continue the theme?		Of course, a whole bunch of users are going to think these names are		somehow meaningful...		The TickCount thing is meaningless - it's just a cheap way to get an		evenly-distributed random number from 0 through 7.		*/		const unsigned char* sillyFileName = NULL;		switch( TickCount() & 0x007 )			{			case 0: sillyFileName = "\pPisaster brevispinus"; break;			case 1: sillyFileName = "\pDermasterias imbricata"; break;			case 2: sillyFileName = "\pPisaster giganteu"; break;			case 3: sillyFileName = "\pPycnopodia helianthoides"; break;			case 4: sillyFileName = "\pPisaster ochraceous"; break;			case 5: sillyFileName = "\pPatiria miniata"; break;			case 6: sillyFileName = "\pLeptasterias hexactis"; break;			case 7: sillyFileName = "\pPatiria miniata"; break;			}		strncpy( (char*)dialogOptions.savedFileName, (char*)sillyFileName, 31 );        /*        Now make the putfile call. This lets the user pick the file and        do all the magical navservices things.         */        anErr = NavPutFile( NULL, &reply, &dialogOptions, eventProc, fileTypeToSave, creatorType, NULL );                             if (anErr == noErr && reply.validRecord)        	{            AEKeyword   theKeyword;            DescType    actualType;            Size        actualSize;            FSSpec      documentFSSpec;                        anErr = AEGetNthPtr(&(reply.selection), 1, typeFSS,                                &theKeyword, &actualType,                                &documentFSSpec, sizeof(documentFSSpec),                                &actualSize );            if (anErr == noErr)            	{                if (reply.replacing)                	{                    anErr = CopyOverwritePictureFile(documentFSSpec, creatorType, fileTypeToSave);                	}                else                	{                    anErr = CopyPictureFile(documentFSSpec, creatorType, fileTypeToSave);                	}                                if ( anErr == noErr)                	{                    // Always call NavCompleteSave() to complete                    anErr = NavCompleteSave(&reply, kNavTranslateInPlace);                	}            	}            (void) NavDisposeReply(&reply);        	}        DisposeNavEventUPP(eventProc);    	}	}static void StartGenerating(void)	{	if(gProgramState == stateIdling)		{		//Set the flag so we know not to start another pattern while this one's running.		gProgramState = stateGenerating;		//Now design a pattern and get to work creating it.		gCurrentPattern = MakeMacGenerator(gPrefs.size);		if(!gCurrentPattern)			{			gProgramState = stateIdling;			//*** TELL THE USER THAT WE COULDN'T MAKE IT WORK			}		//If the status window is open, set it up so the user knows what's going on.		gStatusWindow.SetControlStates();		}	}static void ContinueGenerating(void)	{	if(gProgramState == stateGenerating)		{		//Perform another work unit on the pattern.		MacGeneratorCompute(IsForeground() ? kGreedyTimeSlice : kPoliteTimeSlice, gCurrentPattern);		if(gLastPreviewBoxTicks + 60 < TickCount())			{			//Refresh the preview box to show our current contents once per second.			gStatusWindow.Draw();			gLastPreviewBoxTicks = TickCount();			}		//If we are done, acquire a picture and install it on the desktop.		if(MacGeneratorDone(gCurrentPattern))			{			//Write the image to the desktop.			//***improve this someday so we support multiple monitors			WriteGeneratedImageToDesktop(gCurrentPattern);			//Now shut it all down.			StopGenerating();			}		}	}static void StopGenerating(void)	{	if(gProgramState == stateGenerating)		{		//Throw away the generator.		if(gCurrentPattern)			{			DumpMacGenerator(gCurrentPattern);			gCurrentPattern = NULL;			}		//Turn off the flag, so we don't try to create patterns anymore.		gProgramState = stateIdling;		//Record the current time, so we know when pattern was created.		GetDateTime(&gPrefs.lastPatternTime);		//Figure out when the next pattern should be created.		CalcNextPatternTime();		//Reset the status window to reflect the current state.		gStatusWindow.SetControlStates();		gStatusWindow.Draw();		}	}static void CheckClock(void)	{	/*	Starfish is supposed to generate new desktop patterns at user-specified	intervals. This function checks the clock to see if it is time to create	the next pattern.	Essentially, we check to see whether we are in a when-mode that allows	periodic pattern generation. If so, we check to see whether the current	time has passed the nextPatternTime. If it has, we start up a new	pattern.	*/	if(gPrefs.when != whenCodeNever && gPrefs.when != whenCodeAtStartup)		{		UInt32 curtime;		GetDateTime(&curtime);		if(curtime >= gPrefs.nextPatternTime) StartGenerating();		}	}static void CalcNextPatternTime(void)	{	/*	Work out when the next pattern should be created.	We take the lastPatternTime and add some number of seconds to it.	The number of seconds is determined by the when codes.	*/	UInt32 addtime;	switch(gPrefs.when)		{		case whenCodeNever:		case whenCodeAtStartup:			//42 years must go by before we generate another pattern.			addtime = 0x4EF27300;			break;		case whenCodeDaily:			//Add one day's worth of seconds.			addtime = 0x00015180;			break;		case whenCodeInterval:			//Determine the length based on the value the user typed in.			switch(gPrefs.units)				{				case intervalCodeMinute:					//Multiply the interval by 60 to get seconds.					addtime = gPrefs.interval * 60;					break;				case intervalCodeHour:					//There are 3600 seconds in one hour.					addtime = gPrefs.interval * 3600;					break;				default:					//Dunno what to do with bogus preferences. Just generate nonstop, I guess.					addtime = 0;					break;				}			break;		default:			//Uhhh. Dunno what to do with this, so we just generate lots of patterns.			addtime = 0;			break;		}	gPrefs.nextPatternTime = gPrefs.lastPatternTime + addtime;	}void main()	{	// Initialize the Mac environment.	MacInit();	// Set the preferences to their default values.	PrefsReset();	// If we have a preference file, load its values into our prefs record.	LoadPreferences();	// By default, the program idles until instructed to do something.	gProgramState = stateIdling;	// If the user left the window open when they quit last, reopen it now.	// Use whichever expanded/nonexpanded mode they left the window in.	if(gPrefs.windowOpen) gStatusWindow.Open();	// If the when-code is "at Starfish launch", start generating a pattern now.	if(gPrefs.when == whenCodeAtStartup) StartGenerating();	// Set up the menus to match our current program state.	SetMenuStates();	// Run the event loop until the program is finished.	EventLoop();	// Save the preferences, since they probably changed since the last time we ran.	StorePreferences();	// Quit.	ExitToShell();	}